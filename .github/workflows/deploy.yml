name: Deploy Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'
        type: string

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend
  FRONTEND_IMAGE: ghcr.io/${{ github.repository }}/frontend

jobs:
  deploy-docker-compose:
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'staging' || github.event.inputs.environment == 'development'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull latest images
        run: |
          docker pull ${{ env.BACKEND_IMAGE }}:${{ github.event.inputs.tag || 'latest' }}
          docker pull ${{ env.FRONTEND_IMAGE }}:${{ github.event.inputs.tag || 'latest' }}

      - name: Tag images for local use
        run: |
          docker tag ${{ env.BACKEND_IMAGE }}:${{ github.event.inputs.tag || 'latest' }} hub-defisats-backend:latest
          docker tag ${{ env.FRONTEND_IMAGE }}:${{ github.event.inputs.tag || 'latest' }} hub-defisats-frontend:latest

      - name: Deploy with Docker Compose
        run: |
          # Stop existing containers
          docker-compose -f docker-compose.dev.yml down || true

          # Start services
          docker-compose -f docker-compose.dev.yml up -d

          # Wait for services to be healthy
          echo "Waiting for services to start..."
          sleep 30

          # Check service health
          curl -f http://localhost:13010/health || exit 1
          curl -f http://localhost:3001 || exit 1

      - name: Run database migrations
        run: |
          docker-compose -f docker-compose.dev.yml exec -T backend npx prisma migrate deploy
          docker-compose -f docker-compose.dev.yml exec -T backend npx prisma db push

      - name: Run smoke tests
        run: |
          # Test backend API
          curl -f http://localhost:13010/health

          # Test frontend
          curl -f http://localhost:3001

          # Test database connection
          docker-compose -f docker-compose.dev.yml exec -T backend npx prisma db execute --file=./health-check.sql || echo "SELECT 1" | docker-compose -f docker-compose.dev.yml exec -T db psql -U postgres -d hub_defisats

  deploy-kubernetes:
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'production'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Deploy to Kubernetes
        run: |
          # Update backend deployment
          kubectl set image deployment/hub-defisats-backend backend=${{ env.BACKEND_IMAGE }}:${{ github.event.inputs.tag || 'latest' }}

          # Update frontend deployment
          kubectl set image deployment/hub-defisats-frontend frontend=${{ env.FRONTEND_IMAGE }}:${{ github.event.inputs.tag || 'latest' }}

          # Wait for rollout to complete
          kubectl rollout status deployment/hub-defisats-backend
          kubectl rollout status deployment/hub-defisats-frontend

      - name: Run database migrations
        run: |
          kubectl exec -it deployment/hub-defisats-backend -- npx prisma migrate deploy
          kubectl exec -it deployment/hub-defisats-backend -- npx prisma db push

      - name: Run post-deployment tests
        run: |
          # Wait for ingress to be ready
          sleep 60

          # Test production endpoints
          curl -f https://api.hubdefisats.com/health
          curl -f https://app.hubdefisats.com

  health-check:
    runs-on: ubuntu-latest
    needs: [deploy-docker-compose, deploy-kubernetes]
    if: success()
    steps:
      - name: Health check
        run: |
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            # Production health checks
            curl -f https://api.hubdefisats.com/health
            curl -f https://app.hubdefisats.com/health
          else
            # Staging/development health checks
            curl -f http://localhost:13010/health
            curl -f http://localhost:3001
          fi

  rollback:
    runs-on: ubuntu-latest
    needs: [health-check]
    if: failure()
    steps:
      - name: Rollback deployment
        run: |
          echo "üö® Deployment failed! Initiating rollback..."

          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            # Rollback Kubernetes deployment
            kubectl rollout undo deployment/hub-defisats-backend
            kubectl rollout undo deployment/hub-defisats-frontend
          else
            # Rollback Docker Compose
            docker-compose -f docker-compose.dev.yml down
            docker-compose -f docker-compose.dev.yml up -d --no-deps backend frontend
          fi

      - name: Send rollback notification
        run: |
          echo "üîÑ Rollback completed"
          # Add notification logic here

  notify:
    runs-on: ubuntu-latest
    needs: [health-check, rollback]
    if: always()
    steps:
      - name: Send deployment notification
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment to ${{ github.event.inputs.environment }} successful!"
            # Send success notification
          else
            echo "‚ùå Deployment to ${{ github.event.inputs.environment }} failed!"
            # Send failure notification
          fi

          # Example notification to Slack
          # curl -X POST -H 'Content-type: application/json' \
          # --data "{\"text\":\"Deployment to ${{ github.event.inputs.environment }} ${{ job.status }}\"}" \
          # ${{ secrets.SLACK_WEBHOOK }}

