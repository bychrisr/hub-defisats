---
title: "Security Best Practices"
category: security
subcategory: best-practices
tags: [security, authentication, token-hashing, best-practices, guidelines]
priority: high
status: active
last_updated: 2025-01-22
version: "1.0"
authors: ["Axisor Team"]
reviewers: ["Security Team", "DevOps Team"]
---

# Security Best Practices

## Summary

Comprehensive security best practices guide for the Axisor platform, covering authentication, token management, data protection, and infrastructure security. This document provides guidelines for developers, DevOps, and security teams to maintain high security standards.

## Token Hashing Strategy

### Magic Link Tokens: SHA256 Hashing

**Why SHA256 for Magic Link tokens:**
- Fast verification (no slow bcrypt rounds needed)
- Secure for single-use tokens with short expiration
- GitHub-style implementation (industry standard)
- Resistant to URL truncation issues
- Deterministic hashing for consistent comparison

**Implementation:**
```typescript
// Token generation with SHA256
const token = crypto.randomBytes(32).toString('hex'); // 64 chars
const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

// Token verification
const receivedTokenHash = crypto.createHash('sha256').update(receivedToken).digest('hex');
const isValid = receivedTokenHash === storedTokenHash;
```

**Security Benefits:**
- Prevents plaintext token storage in database
- Resistant to timing attacks
- Fast verification suitable for high-traffic applications
- Industry-standard approach used by GitHub, GitLab

### OTP Codes: bcrypt Hashing

**Why bcrypt for OTP codes:**
- Slower, but acceptable for user-entered codes
- Extra protection against brute force attacks
- Compatible with rate limiting strategies
- Industry standard for password-like data

**Implementation:**
```typescript
// OTP generation and storage
const otp = Math.floor(100000 + Math.random() * 900000).toString();
const otpHash = await bcrypt.hash(otp, 10);

// OTP verification
const isValid = await bcrypt.compare(enteredCode, storedOtpHash);
```

**Security Benefits:**
- Slow verification prevents brute force
- Salted hashing prevents rainbow table attacks
- Configurable work factor for future security needs

### Storage Separation Strategy

**Why separate storage:**
- Prevents conflicts between verification methods
- Allows dual verification (Magic Link + OTP)
- Independent expiration times
- Better security isolation

**Database Schema:**
```sql
-- Magic Link token (SHA256 hash)
email_verification_token VARCHAR(64) -- SHA256 hash
email_verification_expires TIMESTAMP

-- OTP code (bcrypt hash) - temporary storage
password_reset_token VARCHAR(255) -- bcrypt hash
password_reset_expires TIMESTAMP
```

## Authentication Security

### JWT Token Security

**Token Structure:**
```typescript
const jwtPayload = {
  sub: user.id,                    // ✅ Standard JWT field
  email: user.email,
  planType: user.plan_type,       // ✅ Include plan type
  iat: Math.floor(Date.now() / 1000),
  exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60) // 7 days
};
```

**Important**: Always use the standard `sub` field for user ID in JWT payloads. Custom fields like `userId` cause validation issues in middleware that expect standard JWT structure.

**Cookie Configuration:**
```typescript
reply.setCookie('access_token', jwt, {
  httpOnly: true,           // Prevent XSS
  secure: process.env.NODE_ENV === 'production', // HTTPS only in prod
  sameSite: 'lax',          // CSRF protection
  path: '/',                // Available site-wide
  maxAge: 7 * 24 * 60 * 60  // 7 days
});
```

### Password Security

**Hashing Requirements:**
- Use bcrypt with minimum 10 rounds
- Salt automatically generated by bcrypt
- Never store plaintext passwords
- Implement password strength requirements

**Implementation:**
```typescript
// Password hashing
const hashedPassword = await bcrypt.hash(password, 12);

// Password verification
const isValid = await bcrypt.compare(plainPassword, hashedPassword);
```

### Session Management

**Session Security:**
- HttpOnly cookies prevent XSS attacks
- Secure flag in production environments
- SameSite=Lax for CSRF protection
- Reasonable expiration times (7 days)
- Proper logout and token invalidation

## Rate Limiting and Anti-Abuse

### Rate Limiting Strategy

**Endpoint-Specific Limits:**
```typescript
// OTP verification: 5 attempts per 15 minutes
export const otpRateLimit = rateLimit({
  max: 5,
  timeWindow: '15 minutes',
  keyGenerator: (request) => `${request.ip}-${request.body.email}`
});

// Email resend: 3 requests per hour
export const resendRateLimit = rateLimit({
  max: 3,
  timeWindow: '1 hour',
  keyGenerator: (request) => `resend-${request.ip}-${request.body.email}`
});
```

**Progressive Delays:**
- Implement exponential backoff for repeated failures
- Temporary IP blacklisting for abuse patterns
- User-friendly error messages without information leakage

### Anti-Fraud Measures

**IP Tracking:**
```typescript
interface FraudDetection {
  ip: string;
  userAgent: string;
  attempts: number;
  lastAttempt: Date;
  blacklisted: boolean;
}

async trackVerificationAttempt(ip: string, userAgent: string, success: boolean) {
  const key = `fraud:${ip}`;
  const data = await redis.get(key);
  
  if (data) {
    const fraud: FraudDetection = JSON.parse(data);
    fraud.attempts++;
    fraud.lastAttempt = new Date();
    
    if (fraud.attempts > 10) {
      fraud.blacklisted = true;
      await redis.setex(key, 86400, JSON.stringify(fraud)); // 24h ban
    }
  }
}
```

## Data Protection

### Sensitive Data Handling

**Never Log Sensitive Data:**
```typescript
// ❌ BAD - Never log sensitive data
console.log('OTP generated:', otp);
console.log('Token:', token);
console.log('Password:', password);

// ✅ GOOD - Log only non-sensitive information
console.log('OTP generated for user:', userId);
console.log('Token generated, length:', token.length);
console.log('Password hash created for user:', userId);
```

**Environment Variables:**
- Store all secrets in environment variables
- Use different secrets for different environments
- Rotate secrets regularly
- Never commit secrets to version control

### Database Security

**Connection Security:**
- Use SSL/TLS for database connections
- Implement connection pooling
- Use least-privilege database users
- Regular security updates

**Query Security:**
- Use parameterized queries (Prisma ORM)
- Implement input validation
- Avoid raw SQL when possible
- Regular security audits

## Infrastructure Security

### Email Security

**SMTP Configuration:**
- Use TLS/SSL for SMTP connections
- Implement proper authentication
- Monitor delivery rates and bounce rates
- Configure SPF, DKIM, DMARC records

**Email Content:**
- No sensitive data in email content
- Use HTTPS for all links
- Implement email authentication
- Monitor for phishing attempts

### Network Security

**HTTPS Everywhere:**
- Force HTTPS in production
- Use HSTS headers
- Implement proper SSL/TLS configuration
- Regular certificate management

**Firewall Configuration:**
- Restrict database access to application servers
- Implement proper port filtering
- Use VPN for administrative access
- Monitor network traffic

## Monitoring and Alerting

### Security Metrics

**Key Metrics to Monitor:**
- Authentication success/failure rates
- Rate limiting effectiveness
- Email deliverability rates
- Token generation and validation rates
- Failed login attempts per IP

**Alert Conditions:**
```yaml
alerts:
  - name: "High Authentication Failure Rate"
    condition: "auth_failure_rate > 0.1"
    severity: "warning"
    
  - name: "Rate Limiting False Positives"
    condition: "rate_limit_false_positives > 0.01"
    severity: "warning"
    
  - name: "Email Delivery Issues"
    condition: "email_delivery_rate < 0.95"
    severity: "critical"
```

### Logging Best Practices

**Security Event Logging:**
```typescript
// Log security events
logger.info('User verification successful', {
  userId: user.id,
  email: user.email,
  method: 'magic_link',
  ip: request.ip,
  userAgent: request.headers['user-agent']
});

logger.warn('Rate limit exceeded', {
  ip: request.ip,
  email: request.body.email,
  endpoint: request.url,
  attempts: attemptCount
});
```

**Log Analysis:**
- Centralized logging system
- Real-time monitoring
- Automated alerting
- Regular security reviews

## Development Security

### Code Security

**Input Validation:**
```typescript
// Validate all inputs
const emailSchema = z.string().email().max(255);
const passwordSchema = z.string().min(8).max(128);

// Sanitize user inputs
const sanitizedEmail = email.toLowerCase().trim();
```

**Error Handling:**
- Don't expose internal errors to users
- Log detailed errors for debugging
- Implement proper error boundaries
- Use structured error responses

### Dependency Security

**Package Management:**
- Regular dependency updates
- Use `npm audit` for vulnerability scanning
- Implement automated security scanning
- Pin dependency versions

**Code Reviews:**
- Security-focused code reviews
- Automated security scanning
- Regular security training
- Incident response procedures

## Incident Response

### Security Incident Procedures

**Detection:**
- Automated monitoring and alerting
- User reports and feedback
- Regular security audits
- Penetration testing

**Response:**
1. **Immediate**: Contain the incident
2. **Short-term**: Investigate and assess impact
3. **Medium-term**: Implement fixes and patches
4. **Long-term**: Review and improve security measures

**Communication:**
- Internal team notification
- User communication if needed
- Regulatory compliance if required
- Post-incident review and lessons learned

## Compliance and Standards

### Data Protection Regulations

**GDPR Compliance:**
- User consent management
- Data retention policies
- Right to be forgotten
- Data breach notification

**Security Standards:**
- OWASP Top 10 compliance
- Industry best practices
- Regular security assessments
- Third-party security audits

### Documentation Requirements

**Security Documentation:**
- Security architecture documentation
- Incident response procedures
- Security training materials
- Regular security reviews

## Related Documentation

- [Email Verification Security](./authentication/email-verification.md)
- [Authentication API Endpoints](../api/authentication-endpoints.md)
- [Troubleshooting Guide](../troubleshooting/authentication-issues.md)
- [Registration Flow](../features/registration-verification-flow.md)

---

## How to Use This Document

• **For Developers**: Use as reference for implementing secure authentication flows and following security best practices in code.

• **For DevOps**: Use to understand infrastructure security requirements, monitoring needs, and deployment security considerations.

• **For Security Team**: Use to validate security measures, conduct security audits, and ensure compliance with security standards.

• **For Management**: Use to understand security investments, risk management, and compliance requirements.
