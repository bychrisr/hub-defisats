# Relat√≥rio T√©cnico: Debug WebSocket - Market Data n√£o chegando ao Frontend

## √çndice
1. [Resumo Executivo](#resumo-executivo)
2. [Contexto do Problema](#contexto-do-problema)
3. [Arquitetura do Sistema](#arquitetura-do-sistema)
4. [Investiga√ß√£o Detalhada](#investiga√ß√£o-detalhada)
5. [An√°lise de Logs](#an√°lise-de-logs)
6. [Problemas Identificados](#problemas-identificados)
7. [Corre√ß√µes Implementadas](#corre√ß√µes-implementadas)
8. [Testes Realizados](#testes-realizados)
9. [Status Atual](#status-atual)
10. [Pr√≥ximos Passos](#pr√≥ximos-passos)
11. [Anexos](#anexos)

## Resumo Executivo

**Problema Principal**: O frontend n√£o est√° recebendo mensagens `market_data` em tempo real, mesmo com WebSocket conectado e backend emitindo dados.

**Status**: Em investiga√ß√£o ativa - identificamos que o problema est√° na instabilidade das conex√µes WebSocket causada por um loop infinito de reconex√µes no frontend.

**Impacto**: Usu√°rios n√£o recebem atualiza√ß√µes de pre√ßos em tempo real (1 segundo) no header e dashboard.

**Solu√ß√£o Proposta**: Corre√ß√£o do loop infinito de reconex√µes no frontend e estabiliza√ß√£o das conex√µes WebSocket.

## Contexto do Problema

### Situa√ß√£o Atual
- ‚úÖ **WebSocket conecta** (frontend e backend confirmam)
- ‚úÖ **Frontend recebe `lnmarkets_data`** (atualiza√ß√µes de 30s)
- ‚úÖ **Frontend recebe `connection_established`**
- ‚úÖ **Backend emite `market_data_update`** (atualiza√ß√µes de 1s)
- ‚úÖ **Backend faz broadcast de `market_data`**

### Problema Identificado
- ‚ùå **Frontend N√ÉO recebe mensagens `market_data`**
- ‚ùå **Backend mostra `sentCount: 0` no broadcast de `market_data`**

### Requisitos Funcionais
1. **Header de Index**: Atualizar pre√ßo BTC a cada 1 segundo
2. **Dashboard Cards**: Atualizar dados de mercado a cada 1 segundo
3. **LN Markets Header**: Atualizar fees, funding, rate a cada 30 segundos
4. **Sem flicker**: Apenas n√∫meros atualizando, sem recarregar p√°gina

## Arquitetura do Sistema

### Backend - WebSocket Manager
**Arquivo**: `backend/src/websocket/manager.ts`

```typescript
export class WebSocketManager extends EventEmitter {
  private connections: Map<string, WebSocketConnection> = new Map();
  private userConnections: Map<string, Set<string>> = new Map();
  
  broadcast(message: any, options: BroadcastOptions = {}): number {
    let sentCount = 0;
    const { target, type, exclude = [] } = options;
    
    // Logs detalhados implementados para debug
    console.log('üì¢ WEBSOCKET MANAGER - Broadcasting:', { 
      type: message.type, 
      target, 
      excludeCount: exclude.length,
      totalConnections: this.connections.size,
      activeConnectionIds: Array.from(this.connections.keys())
    });
    
    for (const [connectionId, connection] of this.connections) {
      // Verificar filtros e enviar mensagem
      if (this.shouldSendToConnection(connection, message, options)) {
        if (this.sendMessage(connectionId, message)) {
          sentCount++;
        }
      }
    }
    
    return sentCount;
  }
}
```

### Backend - Market Data Handler
**Arquivo**: `backend/src/websocket/handlers/market-data.handler.ts`

```typescript
// Singleton pattern para evitar m√∫ltiplas inst√¢ncias
let marketDataHandlerInstance: MarketDataHandler | null = null;

export class MarketDataHandler extends EventEmitter {
  private subscribers: Set<string> = new Set();
  private cache: Map<string, any> = new Map();
  private wsManager: any;
  
  constructor(logger: Logger) {
    super();
    this.logger = logger;
    console.log('üöÄ MARKET DATA HANDLER - Initializing...');
    this.startMarketDataUpdates(); // 1 segundo
    this.startLNMarketsUpdates(); // 30 segundos
  }
  
  static getInstance(logger: Logger): MarketDataHandler {
    if (!marketDataHandlerInstance) {
      console.log('üì¶ MARKET DATA HANDLER - Creating new singleton instance...');
      marketDataHandlerInstance = new MarketDataHandler(logger);
      console.log('üì¶ MARKET DATA HANDLER - Singleton instance created');
    } else {
      console.log('üì¶ MARKET DATA HANDLER - Using existing singleton instance');
    }
    return marketDataHandlerInstance;
  }
  
  subscribe(connectionId: string, data: any): void {
    const { symbol = 'BTCUSDT' } = data;
    
    console.log('üì° MARKET DATA HANDLER - Subscription added:', { connectionId, symbol });
    
    this.subscribers.add(connectionId);
    
    // Enviar dados atuais se dispon√≠vel em cache
    const cacheKey = `market_${symbol}`;
    const cached = this.cache.get(cacheKey);
    if (cached && this.wsManager) {
      this.wsManager.sendMessage(connectionId, {
        type: 'market_data',
        data: cached,
        timestamp: Date.now()
      });
    }
  }
  
  private async fetchMarketData(symbol: string): Promise<void> {
    try {
      // Buscar dados do Binance
      const binanceData = await this.fetchBinanceData(symbol);
      
      // Armazenar em cache
      this.cache.set(`market_${symbol}`, binanceData);
      
      // Emitir evento
      const eventData = {
        type: 'market_data',
        data: binanceData,
        timestamp: Date.now()
      };
      
      console.log('üì° MARKET DATA HANDLER - About to emit market_data_update event:', {
        eventType: 'market_data_update',
        data: eventData,
        listenerCount: this.listenerCount('market_data_update')
      });
      
      this.emit('market_data_update', eventData);
      
      console.log('‚úÖ MARKET DATA HANDLER - market_data_update event emitted:', {
        eventType: 'market_data_update',
        listenerCount: this.listenerCount('market_data_update')
      });
      
    } catch (error) {
      console.error('‚ùå MARKET DATA HANDLER - Error fetching market data:', error);
    }
  }
}
```

### Backend - WebSocket Routes
**Arquivo**: `backend/src/websocket/routes.ts`

```typescript
export async function websocketConsolidatedRoutes(fastify: FastifyInstance) {
  // Inicializar handlers especializados (usando singleton para MarketDataHandler)
  const marketDataHandler = MarketDataHandler.getInstance(logger);
  const userDataHandler = new UserDataHandler(logger);
  const positionUpdatesHandler = new PositionUpdatesHandler(logger);
  
  // Conectar handlers ao manager
  console.log('üîó WEBSOCKET ROUTES - About to call setupHandlerConnections...');
  try {
    setupHandlerConnections(wsManager, marketDataHandler, userDataHandler, positionUpdatesHandler);
    console.log('‚úÖ WEBSOCKET ROUTES - setupHandlerConnections completed successfully');
  } catch (error) {
    console.error('‚ùå WEBSOCKET ROUTES - Error in setupHandlerConnections:', error);
  }
  
  // Handler para novas conex√µes - notificar handlers especializados
  wsManager.on('connection', (conn) => {
    console.log('üîó WEBSOCKET ROUTES - New connection detected, notifying handlers:', { 
      connectionId: conn.id, 
      userId: conn.userId 
    });
    
    // Notificar MarketDataHandler sobre nova conex√£o
    if (conn.userId) {
      marketDataHandler.subscribe(conn.id, { symbol: 'BTCUSDT' });
    }
  });
}

function setupHandlerConnections(
  wsManager: WebSocketManager,
  marketDataHandler: MarketDataHandler,
  userDataHandler: UserDataHandler,
  positionUpdatesHandler: PositionUpdatesHandler
): void {
  
  // Conectar market data handler
  console.log('üîó WEBSOCKET ROUTES - Registering market_data_update listener...');
  
  marketDataHandler.on('market_data_update', (data) => {
    console.log('üìä WEBSOCKET ROUTES - Market data event received:', JSON.stringify(data).substring(0, 100));
    console.log('üìä WEBSOCKET ROUTES - Broadcasting market data to clients...');
    try {
      wsManager.broadcast(data, { type: 'market_data' });
      console.log('‚úÖ WEBSOCKET ROUTES - Market data broadcasted');
    } catch (error) {
      console.error('‚ùå WEBSOCKET ROUTES - Error broadcasting market data:', error);
    }
  });
  
  console.log('‚úÖ WEBSOCKET ROUTES - market_data_update listener registered');
}
```

### Frontend - Realtime Data Context
**Arquivo**: `frontend/src/contexts/RealtimeDataContext.tsx`

```typescript
export const RealtimeDataProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { user, isAuthenticated } = useAuthStore();
  const isAdmin = user?.role === 'admin';
  
  // WebSocket para dados em tempo real
  const { isConnected, isConnecting, error, connect, disconnect, sendMessage } = useWebSocket({
    url: primaryWsEndpoint,
    urls: wsEndpoints,
    userId: activeUserId,
    onMessage: useCallback((message) => {
      console.log('üìä REALTIME - Mensagem recebida:', {
        type: message.type,
        data: message.data,
        timestamp: new Date().toISOString(),
        userId: user?.id
      });
      
      switch (message.type) {
        case 'connection_established':
          console.log('‚úÖ REALTIME - Conex√£o WebSocket estabelecida:', message.data);
          setData(prev => ({
            ...prev,
            connectionStatus: 'connected',
            lastUpdate: Date.now()
          }));
          break;

        case 'market_data':
          console.log('üìà REALTIME - Processando dados de mercado:', message.data);
          setData(prev => {
            const newData = {
              ...prev,
              marketData: {
                ...prev.marketData,
                [message.data.symbol]: {
                  ...message.data,
                  timestamp: Date.now()
                }
              },
              lastUpdate: Date.now()
            };
            console.log('üìà REALTIME - Dados de mercado atualizados:', newData.marketData);
            return newData;
          });
          break;

        case 'lnmarkets_data':
          console.log('üìä REALTIME - LN Markets data update:', message.data);
          setData(prev => ({
            ...prev,
            lnMarketsData: {
              tradingFees: message.data.tradingFees,
              nextFunding: message.data.nextFunding,
              rate: message.data.rate,
              rateChange: message.data.rateChange,
              timestamp: message.data.timestamp
            },
            lastUpdate: Date.now()
          }));
          break;

        // ... outros casos
      }
    }, [])
  });

  // Conectar quando usu√°rio estiver autenticado (apenas para usu√°rios comuns)
  useEffect(() => {
    console.log('üîÑ REALTIME - useEffect de conex√£o executado:', {
      isAuthenticated,
      userId: user?.id,
      isAdmin,
      timestamp: new Date().toISOString()
    });

    if (isAuthenticated && user?.id && !isAdmin) {
      console.log('üîÑ REALTIME - Conectando para usu√°rio:', user.id);
      
      const endpointPreview = wsEndpoints.map((endpoint) => `${endpoint}?userId=${user.id}`);
      console.log('üîó REALTIME - Tentando conectar usando endpoints:', endpointPreview);
      console.log('üîó REALTIME - VITE_WS_URL env var:', import.meta.env.VITE_WS_URL);
      
      connect();
    } else if (isAdmin) {
      // S√≥ desconectar se for admin
      console.log('üîÑ REALTIME - Desconectando (usu√°rio √© admin):', {
        isAuthenticated,
        hasUserId: !!user?.id,
        isAdmin,
        reason: 'is_admin'
      });
      disconnect();
    } else {
      console.log('üîÑ REALTIME - Aguardando autentica√ß√£o:', {
        isAuthenticated,
        hasUserId: !!user?.id,
        isAdmin,
        reason: 'waiting_for_auth'
      });
      // N√£o desconectar se ainda n√£o foi autenticado
    }
  }, [isAuthenticated, user?.id, isAdmin]);

  return (
    <RealtimeDataContext.Provider value={{
      // ... dados expostos
      lnMarketsData,
      marketData: realtimeMarketData,
      userBalance,
      userPositions,
      isConnected: realtimeConnected,
      // ... outros valores
    }}>
      {children}
    </RealtimeDataContext.Provider>
  );
};
```

### Frontend - Use WebSocket Hook
**Arquivo**: `frontend/src/hooks/useWebSocket.ts`

```typescript
export const useWebSocket = ({
  url,
  urls = [],
  userId,
  onMessage,
  onOpen,
  onClose,
  onError
}: UseWebSocketOptions) => {
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [ws, setWs] = useState<WebSocket | null>(null);
  const [currentUrl, setCurrentUrl] = useState<string | null>(null);
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  const [reconnectTimeout, setReconnectTimeout] = useState<NodeJS.Timeout | null>(null);

  const connect = useCallback(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      console.log('üîÑ WEBSOCKET ENHANCED - Already connected, skipping connection attempt');
      return;
    }

    console.log('üîÑ WEBSOCKET ENHANCED - Starting connection process...');
    console.log('üîÑ WEBSOCKET ENHANCED - Available endpoints:', urls);
    console.log('üîÑ WEBSOCKET ENHANCED - User ID:', userId);

    setIsConnecting(true);
    setError(null);

    // Tentar conectar usando a lista de URLs
    const tryConnect = (urlIndex: number = 0) => {
      if (urlIndex >= urls.length) {
        console.error('‚ùå WEBSOCKET ENHANCED - All connection attempts failed');
        setError('All connection attempts failed');
        setIsConnecting(false);
        return;
      }

      const endpoint = urls[urlIndex];
      const wsUrl = `${endpoint}?userId=${userId}`;
      
      console.log(`üîÑ WEBSOCKET ENHANCED - Attempting connection ${urlIndex + 1}/${urls.length}:`, wsUrl);

      try {
        const newWs = new WebSocket(wsUrl);
        
        newWs.onopen = (event) => {
          console.log('‚úÖ WEBSOCKET ENHANCED - onopen event fired:', {
            endpoint,
            readyState: newWs.readyState,
            url: newWs.url,
            protocol: newWs.protocol,
            openTime: performance.now(),
            event
          });
          
          setIsConnected(true);
          setIsConnecting(false);
          setError(null);
          setReconnectAttempts(0);
          setCurrentUrl(endpoint);
          
          if (onOpen) {
            onOpen(event);
          }
        };

        newWs.onmessage = (event) => {
          console.log('üì® WEBSOCKET ENHANCED - Message received:', {
            type: 'message',
            connectionId: undefined,
            data: event.data,
            timestamp: new Date().toISOString()
          });

          try {
            const message = JSON.parse(event.data);
            console.log('üì® WEBSOCKET ENHANCED - Message received:', {
              type: message.type,
              connectionId: undefined
            });
            
            if (onMessage) {
              onMessage(message);
            }
          } catch (error) {
            console.error('‚ùå WEBSOCKET ENHANCED - Error parsing message:', error);
          }
        };

        newWs.onclose = (event) => {
          console.log('üîå WEBSOCKET ENHANCED - onclose event fired:', {
            endpoint,
            code: event.code,
            reason: event.reason,
            wasClean: event.wasClean,
            closeTime: performance.now()
          });
          
          setIsConnected(false);
          setIsConnecting(false);
          setWs(null);
          
          if (onClose) {
            onClose(event);
          }
        };

        newWs.onerror = (event) => {
          console.log('‚ùå WEBSOCKET ENHANCED - Connection error:', event, { endpoint });
          setError(`Connection error: ${event.type}`);
          setIsConnecting(false);
          
          if (onError) {
            onError(event);
          }
        };

        setWs(newWs);
        
      } catch (error) {
        console.error(`‚ùå WEBSOCKET ENHANCED - Error creating WebSocket for ${endpoint}:`, error);
        // Tentar pr√≥xima URL
        setTimeout(() => tryConnect(urlIndex + 1), 1000);
      }
    };

    tryConnect();
  }, [urls, userId, onMessage, onOpen, onClose, onError]);

  const disconnect = useCallback(() => {
    console.log('üîå WEBSOCKET ENHANCED - Disconnecting...');
    
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      setReconnectTimeout(null);
    }
    
    if (ws) {
      ws.close();
      setWs(null);
    }
    
    setIsConnected(false);
    setIsConnecting(false);
    setReconnectAttempts(0);
  }, [ws, reconnectTimeout]);

  // Auto-connect removido para dar controle ao RealtimeDataContext
  // useEffect(() => {
  //   if (userId && !isConnected && !isConnecting) {
  //     connect();
  //   }
  // }, [userId, isConnected, isConnecting, connect]);

  return {
    isConnected,
    isConnecting,
    error,
    connect,
    disconnect,
    sendMessage: useCallback((message: any) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
        return true;
      }
      return false;
    }, [ws])
  };
};
```

## Investiga√ß√£o Detalhada

### Hip√≥tese Central
O backend est√° fazendo broadcast de `market_data`, mas o `WebSocketManager` n√£o est√° enviando para nenhum cliente ativo (`sentCount: 0`).

**Poss√≠veis Causas**:
1. N√£o h√° clientes registrados no momento do broadcast
2. Os clientes est√£o registrados mas n√£o est√£o recebendo mensagens `market_data` especificamente
3. Filtros no broadcast est√£o excluindo os clientes
4. M√∫ltiplas inst√¢ncias do `MarketDataHandler` est√£o causando problemas

### Metodologia de Debug
1. **Logs Detalhados**: Implementamos logs em todos os pontos cr√≠ticos
2. **Rastreamento de Conex√µes**: Monitoramos cria√ß√£o, fechamento e status das conex√µes
3. **An√°lise de Broadcast**: Verificamos por que `sentCount: 0`
4. **Singleton Pattern**: Garantimos uma √∫nica inst√¢ncia do `MarketDataHandler`

## An√°lise de Logs

### Logs do Backend

#### 1. Verifica√ß√£o de Conex√µes Ativas
```bash
docker logs axisor-backend 2>&1 | tail -100 | grep -E "(totalConnections)" | tail -5
```
**Resultado**: 
```
  totalConnections: 0,
  totalConnections: 0,
  totalConnections: 0,
```
**An√°lise**: N√£o h√° clientes conectados no momento do broadcast.

#### 2. Verifica√ß√£o de Broadcast
```bash
docker logs axisor-backend 2>&1 | tail -100 | grep -E "(Broadcast completed)" | tail -5
```
**Resultado**: 
```
‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }
‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }
‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }
```
**An√°lise**: Nenhuma mensagem est√° sendo enviada para os clientes.

#### 3. Verifica√ß√£o de Conex√µes Criadas
```bash
docker logs axisor-backend 2>&1 | grep -E "(Connection created)" | tail -5
```
**Resultado**: 
```
‚úÖ WEBSOCKET ROUTES - Connection created successfully: {
‚úÖ WEBSOCKET MANAGER - Connection created: {
‚úÖ WEBSOCKET ROUTES - Connection created successfully: {
‚úÖ WEBSOCKET MANAGER - Connection created: {
‚úÖ WEBSOCKET ROUTES - Connection created successfully: {
```
**An√°lise**: Conex√µes est√£o sendo criadas com sucesso.

#### 4. Verifica√ß√£o de Conex√µes Fechadas
```bash
docker logs axisor-backend 2>&1 | grep -E "(Connection closed)" | tail -5
```
**Resultado**: 
```
üîå WEBSOCKET ROUTES - Connection closed: { connectionId: 'ws_1761270895622_x4v5ug6tr' }
üîå WEBSOCKET ROUTES - Connection closed: { connectionId: 'ws_1761270946618_7yvwwj1nh' }
üîå WEBSOCKET ROUTES - Connection closed: { connectionId: 'ws_1761271120614_d1npppzxa' }
üîå WEBSOCKET MANAGER - Connection closed: {
üîå WEBSOCKET ROUTES - Connection closed: { connectionId: 'ws_1761271216610_1x9p6x4xx' }
```
**An√°lise**: Conex√µes est√£o sendo fechadas rapidamente ap√≥s serem criadas.

#### 5. Verifica√ß√£o de Subscriptions
```bash
docker logs axisor-backend 2>&1 | grep -E "(Subscription added)" | tail -5
```
**Resultado**: 
```
üì° MARKET DATA HANDLER - Subscription added: { connectionId: 'ws_1761270831610_65xy857jw', symbol: 'BTCUSDT' }
üì° MARKET DATA HANDLER - Subscription added: { connectionId: 'ws_1761270895622_x4v5ug6tr', symbol: 'BTCUSDT' }
üì° MARKET DATA HANDLER - Subscription added: { connectionId: 'ws_1761270946618_7yvwwj1nh', symbol: 'BTCUSDT' }
üì° MARKET DATA HANDLER - Subscription added: { connectionId: 'ws_1761271120614_d1npppzxa', symbol: 'BTCUSDT' }
üì° MARKET DATA HANDLER - Subscription added: { connectionId: 'ws_1761271216610_1x9p6x4xx', symbol: 'BTCUSDT' }
```
**An√°lise**: Subscriptions est√£o sendo adicionadas corretamente.

#### 6. Verifica√ß√£o de Singleton Pattern
```bash
docker logs axisor-backend 2>&1 | grep -E "(Singleton instance created)" | tail -10
```
**Resultado**: 
```
üì¶ MARKET DATA HANDLER - Singleton instance created
üì¶ MARKET DATA HANDLER - Singleton instance created
üì¶ MARKET DATA HANDLER - Singleton instance created
üì¶ MARKET DATA HANDLER - Singleton instance created
üì¶ MARKET DATA HANDLER - Singleton instance created
```
**An√°lise**: M√∫ltiplas inst√¢ncias est√£o sendo criadas, indicando problema no singleton.

### Logs do Frontend

#### 1. Verifica√ß√£o de Conex√£o WebSocket
```bash
cd /home/bychrisr/projects/axisor && grep -E "(WEBSOCKET ENHANCED.*onopen|REALTIME.*Conectando)" logs-console/localhost-1761270433261.log | tail -5
```
**Resultado**: 
```
RealtimeDataContext.tsx:489 üîÑ REALTIME - Conectando para usu√°rio: 20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98
 ‚úÖ WEBSOCKET ENHANCED - onopen event fired: {endpoint: 'ws://localhost:13010/api/ws', readyState: 1, url: 'ws://localhost:13010/api/ws?userId=20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98', protocol: '', openTime: 3153.10000000149, ‚Ä¶}
```
**An√°lise**: Frontend est√° conectando ao WebSocket com sucesso.

#### 2. Verifica√ß√£o de Desconex√£o
```bash
cd /home/bychrisr/projects/axisor && grep -E "(REALTIME.*Desconectando|REALTIME.*Aguardando)" logs-console/localhost-1761270433261.log | tail -10
```
**Resultado**: 
```
RealtimeDataContext.tsx:498 üîÑ REALTIME - Desconectando (usu√°rio deslogou): {isAuthenticated: false, hasUserId: true, isAdmin: false, reason: 'user_logged_out'}
RealtimeDataContext.tsx:489 üîÑ REALTIME - Conectando para usu√°rio: 20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98
```
**An√°lise**: Frontend est√° desconectando e reconectando em loop infinito.

#### 3. Verifica√ß√£o de Mensagens Recebidas
```bash
cd /home/bychrisr/projects/axisor && grep -E "(Message received|market_data|BTCUSDT)" logs-console/localhost-1761270433261.log | head -20
```
**Resultado**: 
```
 üîÑ HISTORICAL - Loading initial data: {symbol: 'BINANCE:BTCUSDT', timeframe: '1h', limit: 168}
marketData.service.ts:99 üîÑ MARKET DATA - Fetching historical data via TradingView proxy: {symbol: 'BINANCE:BTCUSDT', timeframe: '1h', limit: 168, startTime: undefined}
useHistoricalData.ts:72 üîÑ HISTORICAL - Loading initial data: {symbol: 'BTCUSDT', timeframe: '1h', limit: 168}
marketData.service.ts:99 üîÑ MARKET DATA - Fetching historical data via TradingView proxy: {symbol: 'BTCUSDT', timeframe: '1h', limit: 168, startTime: undefined}
 üì® WEBSOCKET ENHANCED - Message received: {type: 'lnmarkets_data', connectionId: undefined}
 üì® WEBSOCKET ENHANCED - Message received: {type: 'connection_established', connectionId: 'ws_1761270414442_k5zolqh4h'}
```
**An√°lise**: Frontend recebe `lnmarkets_data` e `connection_established`, mas n√£o recebe `market_data`.

## Problemas Identificados

### Problema 1: Loop Infinito de Reconex√µes no Frontend
**Causa**: O `useEffect` no `RealtimeDataContext.tsx` est√° sendo executado duas vezes:
1. **Primeira vez**: `isAuthenticated: false` ‚Üí chama `disconnect()`
2. **Segunda vez**: `isAuthenticated: true` ‚Üí chama `connect()`

**Evid√™ncia**:
```javascript
// Log do frontend
üîÑ REALTIME - Desconectando (usu√°rio deslogou): {isAuthenticated: false, hasUserId: true, isAdmin: false, reason: 'user_logged_out'}
üîÑ REALTIME - Conectando para usu√°rio: 20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98
```

**Impacto**: Instabilidade nas conex√µes WebSocket, causando fechamento r√°pido das conex√µes.

### Problema 2: M√∫ltiplas Inst√¢ncias do MarketDataHandler
**Causa**: O singleton pattern n√£o estava funcionando corretamente, criando m√∫ltiplas inst√¢ncias.

**Evid√™ncia**:
```bash
docker logs axisor-backend 2>&1 | grep -E "(Singleton instance created)" | tail -10
```
**Resultado**: M√∫ltiplas inst√¢ncias sendo criadas em vez de reutilizar a existente.

**Impacto**: Subscriptions sendo adicionadas em uma inst√¢ncia, mas broadcasts sendo feitos em outra.

### Problema 3: Conex√µes Sendo Fechadas Rapidamente
**Causa**: O frontend est√° desconectando rapidamente devido ao loop infinito de reconex√µes.

**Evid√™ncia**: 
- Conex√µes s√£o criadas: `‚úÖ WEBSOCKET ROUTES - Connection created successfully`
- Subscriptions s√£o adicionadas: `üì° MARKET DATA HANDLER - Subscription added`
- Conex√µes s√£o fechadas: `üîå WEBSOCKET ROUTES - Connection closed`
- Broadcast com `sentCount: 0`: `‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }`

**Impacto**: Backend n√£o consegue enviar mensagens porque n√£o h√° clientes ativos.

### Problema 4: Filtros no Broadcast
**Causa**: O `WebSocketManager` est√° aplicando filtros que podem estar excluindo clientes.

**Evid√™ncia**: Logs de "Skipping connection" n√£o aparecem, indicando que o loop n√£o est√° sendo executado.

**Impacto**: Mensagens n√£o s√£o enviadas mesmo com clientes conectados.

## Corre√ß√µes Implementadas

### Corre√ß√£o 1: Singleton Pattern para MarketDataHandler
**Arquivo**: `backend/src/websocket/handlers/market-data.handler.ts`

```typescript
// Singleton pattern para evitar m√∫ltiplas inst√¢ncias
let marketDataHandlerInstance: MarketDataHandler | null = null;

export class MarketDataHandler extends EventEmitter {
  static getInstance(logger: Logger): MarketDataHandler {
    if (!marketDataHandlerInstance) {
      console.log('üì¶ MARKET DATA HANDLER - Creating new singleton instance...');
      marketDataHandlerInstance = new MarketDataHandler(logger);
      console.log('üì¶ MARKET DATA HANDLER - Singleton instance created');
    } else {
      console.log('üì¶ MARKET DATA HANDLER - Using existing singleton instance');
    }
    return marketDataHandlerInstance;
  }
}
```

**Status**: ‚úÖ Implementado

### Corre√ß√£o 2: Logs Detalhados no WebSocketManager
**Arquivo**: `backend/src/websocket/manager.ts`

```typescript
broadcast(message: any, options: BroadcastOptions = {}): number {
  let sentCount = 0;
  const { target, type, exclude = [] } = options;

  console.log('üì¢ WEBSOCKET MANAGER - Broadcasting:', { 
    type: message.type, 
    target, 
    excludeCount: exclude.length,
    totalConnections: this.connections.size,
    activeConnectionIds: Array.from(this.connections.keys())
  });

  console.log('üîÑ WEBSOCKET MANAGER - Starting broadcast loop...');
  for (const [connectionId, connection] of this.connections) {
    console.log('üîç WEBSOCKET MANAGER - Checking connection:', {
      id: connectionId,
      userId: connection.userId,
      subscriptions: Array.from(connection.subscriptions),
      hasTarget: !!target,
      isExcluded: exclude.includes(connectionId),
      hasTypeFilter: !!type,
      hasSubscription: type ? connection.subscriptions.has(type) : true
    });

    // Pular conex√µes exclu√≠das
    if (exclude.includes(connectionId)) {
      console.log('‚è≠Ô∏è WEBSOCKET MANAGER - Skipping excluded connection:', connectionId);
      continue;
    }

    // Filtrar por target (userId)
    if (target && connection.userId !== target) {
      console.log('‚è≠Ô∏è WEBSOCKET MANAGER - Skipping connection (wrong target):', {
        connectionId,
        connectionUserId: connection.userId,
        target
      });
      continue;
    }

    // Filtrar por tipo de subscription
    if (type && !connection.subscriptions.has(type)) {
      console.log('‚è≠Ô∏è WEBSOCKET MANAGER - Skipping connection (no subscription):', {
        connectionId,
        requiredType: type,
        userSubscriptions: Array.from(connection.subscriptions)
      });
      continue;
    }

    // Enviar mensagem
    if (this.sendMessage(connectionId, message)) {
      sentCount++;
      console.log('‚úÖ WEBSOCKET MANAGER - Message sent to:', connectionId);
    } else {
      console.log('‚ùå WEBSOCKET MANAGER - Failed to send to:', connectionId);
    }
  }

  console.log('‚úÖ WEBSOCKET MANAGER - Broadcast completed:', { sentCount });
  return sentCount;
}
```

**Status**: ‚úÖ Implementado

### Corre√ß√£o 3: L√≥gica de Desconex√£o no Frontend
**Arquivo**: `frontend/src/contexts/RealtimeDataContext.tsx`

```typescript
// Conectar quando usu√°rio estiver autenticado (apenas para usu√°rios comuns)
useEffect(() => {
  console.log('üîÑ REALTIME - useEffect de conex√£o executado:', {
    isAuthenticated,
    userId: user?.id,
    isAdmin,
    timestamp: new Date().toISOString()
  });

  if (isAuthenticated && user?.id && !isAdmin) {
    console.log('üîÑ REALTIME - Conectando para usu√°rio:', user.id);
    
    const endpointPreview = wsEndpoints.map((endpoint) => `${endpoint}?userId=${user.id}`);
    console.log('üîó REALTIME - Tentando conectar usando endpoints:', endpointPreview);
    console.log('üîó REALTIME - VITE_WS_URL env var:', import.meta.env.VITE_WS_URL);
    
    connect();
  } else if (isAdmin) {
    // S√≥ desconectar se for admin
    console.log('üîÑ REALTIME - Desconectando (usu√°rio √© admin):', {
      isAuthenticated,
      hasUserId: !!user?.id,
      isAdmin,
      reason: 'is_admin'
    });
    disconnect();
  } else {
    console.log('üîÑ REALTIME - Aguardando autentica√ß√£o:', {
      isAuthenticated,
      hasUserId: !!user?.id,
      isAdmin,
      reason: 'waiting_for_auth'
    });
    // N√£o desconectar se ainda n√£o foi autenticado
  }
}, [isAuthenticated, user?.id, isAdmin]);
```

**Status**: ‚úÖ Implementado

### Corre√ß√£o 4: Remo√ß√£o do Auto-connect no useWebSocket
**Arquivo**: `frontend/src/hooks/useWebSocket.ts`

```typescript
// Auto-connect removido para dar controle ao RealtimeDataContext
// useEffect(() => {
//   if (userId && !isConnected && !isConnecting) {
//     connect();
//   }
// }, [userId, isConnected, isConnecting, connect]);
```

**Status**: ‚úÖ Implementado

### Corre√ß√£o 5: Listener para Novas Conex√µes
**Arquivo**: `backend/src/websocket/routes.ts`

```typescript
// Handler para novas conex√µes - notificar handlers especializados
wsManager.on('connection', (conn) => {
  console.log('üîó WEBSOCKET ROUTES - New connection detected, notifying handlers:', { 
    connectionId: conn.id, 
    userId: conn.userId 
  });
  
  // Notificar MarketDataHandler sobre nova conex√£o
  if (conn.userId) {
    marketDataHandler.subscribe(conn.id, { symbol: 'BTCUSDT' });
  }
});
```

**Status**: ‚úÖ Implementado

## Testes Realizados

### Teste 1: Verifica√ß√£o de Conex√µes Ativas
**Comando**: 
```bash
docker logs axisor-backend 2>&1 | tail -100 | grep -E "(totalConnections)" | tail -5
```
**Resultado**: `totalConnections: 0`
**Status**: ‚ùå Falhou - N√£o h√° clientes conectados

### Teste 2: Verifica√ß√£o de Broadcast
**Comando**: 
```bash
docker logs axisor-backend 2>&1 | tail -100 | grep -E "(Broadcast completed)" | tail -5
```
**Resultado**: `‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }`
**Status**: ‚ùå Falhou - Nenhuma mensagem enviada

### Teste 3: Verifica√ß√£o de Conex√µes Criadas
**Comando**: 
```bash
docker logs axisor-backend 2>&1 | grep -E "(Connection created)" | tail -5
```
**Resultado**: M√∫ltiplas conex√µes criadas
**Status**: ‚úÖ Sucesso - Conex√µes sendo criadas

### Teste 4: Verifica√ß√£o de Conex√µes Fechadas
**Comando**: 
```bash
docker logs axisor-backend 2>&1 | grep -E "(Connection closed)" | tail -5
```
**Resultado**: M√∫ltiplas conex√µes fechadas
**Status**: ‚ùå Falhou - Conex√µes sendo fechadas rapidamente

### Teste 5: Verifica√ß√£o de Subscriptions
**Comando**: 
```bash
docker logs axisor-backend 2>&1 | grep -E "(Subscription added)" | tail -5
```
**Resultado**: M√∫ltiplas subscriptions adicionadas
**Status**: ‚úÖ Sucesso - Subscriptions sendo adicionadas

### Teste 6: Verifica√ß√£o de Singleton Pattern
**Comando**: 
```bash
docker logs axisor-backend 2>&1 | grep -E "(Singleton instance created)" | tail -10
```
**Resultado**: M√∫ltiplas inst√¢ncias criadas
**Status**: ‚ùå Falhou - Singleton n√£o funcionando

### Teste 7: Verifica√ß√£o de Frontend WebSocket
**Comando**: 
```bash
cd /home/bychrisr/projects/axisor && grep -E "(WEBSOCKET ENHANCED.*onopen|REALTIME.*Conectando)" logs-console/localhost-1761270433261.log | tail -5
```
**Resultado**: Frontend conectando com sucesso
**Status**: ‚úÖ Sucesso - Frontend conectando

### Teste 8: Verifica√ß√£o de Loop Infinito
**Comando**: 
```bash
cd /home/bychrisr/projects/axisor && grep -E "(REALTIME.*Desconectando|REALTIME.*Aguardando)" logs-console/localhost-1761270433261.log | tail -10
```
**Resultado**: Loop infinito de desconex√µes
**Status**: ‚ùå Falhou - Loop infinito persistindo

## Status Atual

### Problemas Resolvidos
- ‚úÖ **Logs detalhados implementados** - Agora temos visibilidade completa do fluxo
- ‚úÖ **Singleton pattern implementado** - Evita m√∫ltiplas inst√¢ncias do MarketDataHandler
- ‚úÖ **Listener para novas conex√µes implementado** - MarketDataHandler √© notificado sobre novas conex√µes
- ‚úÖ **Auto-connect removido** - RealtimeDataContext tem controle total sobre conex√µes

### Problemas Persistentes
- ‚ùå **Loop infinito de reconex√µes** - Frontend ainda desconecta e reconecta rapidamente
- ‚ùå **Conex√µes sendo fechadas rapidamente** - Backend n√£o consegue manter conex√µes est√°veis
- ‚ùå **sentCount: 0** - Nenhuma mensagem sendo enviada para clientes
- ‚ùå **totalConnections: 0** - N√£o h√° clientes ativos no momento do broadcast

### Evid√™ncias Atuais
```bash
# Backend logs
‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }
  totalConnections: 0,

# Frontend logs (antigos)
üîÑ REALTIME - Desconectando (usu√°rio deslogou): {isAuthenticated: false, hasUserId: true, isAdmin: false, reason: 'user_logged_out'}
üîÑ REALTIME - Conectando para usu√°rio: 20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98
```

## Pr√≥ximos Passos

### 1. Verificar se as corre√ß√µes no frontend est√£o sendo aplicadas
- Coletar logs mais recentes do frontend
- Verificar se o loop infinito de reconex√µes foi resolvido
- Confirmar se as corre√ß√µes est√£o sendo aplicadas corretamente

### 2. Testar estabilidade das conex√µes
- Verificar se as conex√µes WebSocket permanecem est√°veis
- Confirmar se o `totalConnections > 0` durante broadcasts
- Verificar se o `sentCount > 0` nos broadcasts

### 3. Validar recebimento de mensagens
- Confirmar se o frontend recebe mensagens `market_data`
- Verificar se os dados s√£o atualizados em tempo real
- Testar se n√£o h√° mais logs de desconex√£o desnecess√°rios

### 4. Monitoramento cont√≠nuo
- Implementar alertas para conex√µes inst√°veis
- Adicionar m√©tricas de performance
- Documentar procedimentos de troubleshooting

## Comandos de Debug

### Backend
```bash
# Verificar conex√µes ativas
docker logs axisor-backend 2>&1 | tail -100 | grep -E "(totalConnections)" | tail -5

# Verificar broadcasts
docker logs axisor-backend 2>&1 | tail -100 | grep -E "(Broadcast completed)" | tail -5

# Verificar conex√µes criadas
docker logs axisor-backend 2>&1 | grep -E "(Connection created)" | tail -5

# Verificar conex√µes fechadas
docker logs axisor-backend 2>&1 | grep -E "(Connection closed)" | tail -5

# Verificar subscriptions
docker logs axisor-backend 2>&1 | grep -E "(Subscription added)" | tail -5

# Verificar singleton
docker logs axisor-backend 2>&1 | grep -E "(Singleton instance created)" | tail -10

# Verificar logs detalhados de broadcast
docker logs axisor-backend 2>&1 | tail -200 | grep -E "(Checking connection|Skipping connection|Message sent to)" | tail -10
```

### Frontend
```bash
# Verificar logs mais recentes
cd /home/bychrisr/projects/axisor && ls -la logs-console/ | tail -1

# Verificar conex√£o WebSocket
cd /home/bychrisr/projects/axisor && grep -E "(WEBSOCKET ENHANCED.*onopen|REALTIME.*Conectando)" logs-console/localhost-1761270433261.log | tail -5

# Verificar loop infinito
cd /home/bychrisr/projects/axisor && grep -E "(REALTIME.*Desconectando|REALTIME.*Aguardando)" logs-console/localhost-1761270433261.log | tail -10

# Verificar mensagens recebidas
cd /home/bychrisr/projects/axisor && grep -E "(Message received|market_data|BTCUSDT)" logs-console/localhost-1761270433261.log | head -20
```

### Docker
```bash
# Reiniciar backend
docker-compose -f config/docker/docker-compose.dev.yml restart backend

# Reiniciar frontend
docker-compose -f config/docker/docker-compose.dev.yml restart frontend

# Verificar status dos containers
docker-compose -f config/docker/docker-compose.dev.yml ps

# Verificar logs em tempo real
docker-compose -f config/docker/docker-compose.dev.yml logs -f backend
docker-compose -f config/docker/docker-compose.dev.yml logs -f frontend
```

## Anexos

### Anexo A: Estrutura de Arquivos
```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ websocket/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.ts                 # WebSocketManager
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.ts                  # WebSocket routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ market-data.handler.ts # MarketDataHandler
‚îÇ   ‚îî‚îÄ‚îÄ index.ts                       # Entry point
‚îî‚îÄ‚îÄ package.json

frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ contexts/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RealtimeDataContext.tsx   # Context para dados em tempo real
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useWebSocket.ts           # Hook para WebSocket
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ layout/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ LNMarketsHeader.tsx   # Header LN Markets
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ UnifiedMarketHeader.tsx # Header geral
‚îÇ       ‚îî‚îÄ‚îÄ dashboard/
‚îÇ           ‚îî‚îÄ‚îÄ DashboardClassic.tsx  # Dashboard principal
‚îî‚îÄ‚îÄ package.json

config/
‚îî‚îÄ‚îÄ docker/
    ‚îî‚îÄ‚îÄ docker-compose.dev.yml        # Configura√ß√£o Docker
```

### Anexo B: Fluxo de Dados
```
1. Frontend conecta ao WebSocket
2. Backend cria conex√£o e notifica MarketDataHandler
3. MarketDataHandler adiciona subscription
4. MarketDataHandler busca dados do Binance (1s)
5. MarketDataHandler emite evento 'market_data_update'
6. WebSocket routes escuta evento e faz broadcast
7. WebSocketManager envia para clientes conectados
8. Frontend recebe mensagem e atualiza estado
```

### Anexo C: Configura√ß√µes Docker
```yaml
# config/docker/docker-compose.dev.yml
version: '3.8'
services:
  backend:
    build:
      context: ../../backend
      dockerfile: Dockerfile.dev
    ports:
      - "13010:3010"  # Externo:Interno
    environment:
      - NODE_ENV=development
    volumes:
      - ../../backend:/app
    networks:
      - axisor-network

  frontend:
    build:
      context: ../../frontend
      dockerfile: Dockerfile.dev
    ports:
      - "13000:3001"  # Externo:Interno
    environment:
      - VITE_WS_URL=ws://localhost:13010/api/ws
    volumes:
      - ../../frontend:/app
    networks:
      - axisor-network
    depends_on:
      - backend

networks:
  axisor-network:
    driver: bridge
```

### Anexo D: Vari√°veis de Ambiente
```bash
# Frontend
VITE_WS_URL=ws://localhost:13010/api/ws

# Backend
NODE_ENV=development
PORT=3010
```

### Anexo E: Logs de Exemplo
```
# Backend - Conex√£o criada
‚úÖ WEBSOCKET ROUTES - Connection created successfully: {
  connectionId: 'ws_1761271216610_1x9p6x4xx',
  userId: '20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98',
  timestamp: '2025-01-23T01:56:45.123Z'
}

# Backend - Subscription adicionada
üì° MARKET DATA HANDLER - Subscription added: { 
  connectionId: 'ws_1761271216610_1x9p6x4xx', 
  symbol: 'BTCUSDT' 
}

# Backend - Broadcast
üì¢ WEBSOCKET MANAGER - Broadcasting: {
  type: 'market_data',
  totalConnections: 0,
  activeConnectionIds: []
}

# Backend - Resultado do broadcast
‚úÖ WEBSOCKET MANAGER - Broadcast completed: { sentCount: 0 }

# Frontend - Conex√£o
‚úÖ WEBSOCKET ENHANCED - onopen event fired: {
  endpoint: 'ws://localhost:13010/api/ws',
  readyState: 1,
  url: 'ws://localhost:13010/api/ws?userId=20dbbe5f-6bd3-4fc0-84d5-7dbb9558bd98'
}

# Frontend - Desconex√£o
üîÑ REALTIME - Desconectando (usu√°rio deslogou): {
  isAuthenticated: false,
  hasUserId: true,
  isAdmin: false,
  reason: 'user_logged_out'
}
```

---

**Data do Relat√≥rio**: 23 de Janeiro de 2025  
**Vers√£o**: 1.0  
**Autor**: Sistema de Debug WebSocket  
**Status**: Em Investiga√ß√£o Ativa
