generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         String           @id @default(dbgenerated("(gen_random_uuid())::text"))
  email                      String           @unique
  username                   String           @unique
  password_hash              String?
  social_provider            String?
  social_id                  String?
  ln_markets_api_key         String?
  ln_markets_api_secret      String?
  plan_type                  PlanType         @default(free)
  last_activity_at           DateTime?        @db.Timestamp(6)
  created_at                 DateTime         @default(now()) @db.Timestamp(6)
  updated_at                 DateTime         @default(now()) @db.Timestamp(6)
  is_active                  Boolean          @default(true)
  session_expires_at         DateTime?        @db.Timestamp(6)
  email_verified             Boolean?         @default(false)
  email_verification_token   String?
  email_verification_expires DateTime?        @db.Timestamp(6)
  password_reset_token       String?
  password_reset_expires     DateTime?        @db.Timestamp(6)
  two_factor_enabled         Boolean?         @default(false)
  two_factor_secret          String?
  two_factor_backup_codes    Json?
  login_attempts             Int?             @default(0)
  locked_until               DateTime?        @db.Timestamp(6)
  last_login_ip              String?
  last_login_user_agent      String?
  ln_markets_passphrase      String?          @db.VarChar(255)
  admin_user                 AdminUser?
  automations                Automation[]
  backtest_reports           BacktestReport[]
  notifications              Notification[]
  payments                   Payment[]
  trade_logs                 TradeLog[]
  user_coupons               UserCoupon[]     @relation("UserCouponRelation")
  upgrade_history            UserUpgradeHistory[] @relation("UserUpgradeHistory")
  upgrades_made              UserUpgradeHistory[] @relation("AdminUpgradeHistory")
  simulations                Simulation[]

  @@index([email], map: "idx_user_email")
  @@index([email_verification_token], map: "idx_user_email_verification_token")
  @@index([password_reset_token], map: "idx_user_password_reset_token")
}

model Automation {
  id         String     @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id    String
  type       String
  config     Json
  is_active  Boolean    @default(true)
  created_at DateTime   @default(now()) @db.Timestamp(6)
  updated_at DateTime   @default(now()) @db.Timestamp(6)
  user       User       @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  trade_logs TradeLog[]

  @@index([user_id], map: "idx_automation_user_id")
}

model TradeLog {
  id            String      @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id       String
  automation_id String?
  /// LN Markets trade ID
  trade_id      String
  status        String
  error_message String?
  executed_at   DateTime    @db.Timestamp(6)
  created_at    DateTime    @default(now()) @db.Timestamp(6)
  automation    Automation? @relation(fields: [automation_id], references: [id], onUpdate: NoAction)
  user          User        @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([automation_id], map: "idx_tradelog_automation_id")
  @@index([user_id], map: "idx_tradelog_user_id")
}

model Notification {
  id             String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id        String
  type           String
  is_enabled     Boolean  @default(true)
  channel_config Json
  created_at     DateTime @default(now()) @db.Timestamp(6)
  updated_at     DateTime @default(now()) @db.Timestamp(6)
  user           User     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([user_id], map: "idx_notification_user_id")
}

model Payment {
  id                String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id           String
  plan_type         PlanType
  amount_sats       Int
  lightning_invoice String
  status            String
  paid_at           DateTime? @db.Timestamp(6)
  created_at        DateTime  @default(now()) @db.Timestamp(6)
  updated_at        DateTime  @default(now()) @db.Timestamp(6)
  user              User      @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([user_id], map: "idx_payment_user_id")
}

model BacktestReport {
  id         String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id    String
  config     Json
  result     Json
  created_at DateTime @default(now()) @db.Timestamp(6)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([user_id], map: "idx_backtestreport_user_id")
}

model AdminUser {
  id         String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id    String   @unique
  role       String
  created_at DateTime @default(now()) @db.Timestamp(6)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([user_id], map: "idx_adminuser_user_id")
}

model Coupon {
  id           String       @id @default(dbgenerated("(gen_random_uuid())::text"))
  code         String       @unique
  usage_limit  Int?         @default(1)
  used_count   Int?         @default(0)
  plan_type    PlanType
  expires_at   DateTime?    @db.Timestamp(6)
  
  // Novos campos para o sistema de cupons
  value_type   String       // 'fixed' ou 'percentage'
  value_amount Int          // Valor fixo em sats ou percentual (1-100)
  time_type    String       // 'fixed' ou 'lifetime'
  time_days    Int?         // Número de dias (apenas se time_type = 'fixed')
  
  // Campos para administração
  is_active    Boolean      @default(true)  // Ativo/Inativo
  description  String?      // Descrição do cupom
  created_by   String?      // ID do admin que criou
  
  // Métricas
  total_revenue_saved Int   @default(0)    // Total de receita economizada (em sats)
  new_users_count    Int    @default(0)    // Número de novos usuários atraídos
  conversion_rate    Float  @default(0)    // Taxa de conversão
  
  created_at   DateTime     @default(now()) @db.Timestamp(6)
  updated_at   DateTime     @default(now()) @db.Timestamp(6)
  user_coupons UserCoupon[] @relation("CouponUserRelation")

  @@index([code], map: "idx_coupon_code")
  @@index([is_active], map: "idx_coupon_active")
  @@index([created_at], map: "idx_coupon_created")
}

model SystemAlert {
  id         String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  message    String
  severity   String
  is_global  Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamp(6)
}

/// Join table for User-Coupon N:N relationship
/// Each user can redeem a coupon once
model UserCoupon {
  user_id   String
  coupon_id String
  used_at   DateTime @default(now()) @db.Timestamp(6)
  coupon    Coupon   @relation("CouponUserRelation", fields: [coupon_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user      User     @relation("UserCouponRelation", fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([user_id, coupon_id])
}

/// Modelo para rastrear métricas de cupons
model CouponAnalytics {
  id                String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  coupon_id         String
  date              DateTime @db.Timestamp(6)
  
  // Métricas do dia
  views_count       Int      @default(0)    // Quantas vezes o cupom foi visualizado
  clicks_count      Int      @default(0)    // Quantas vezes foi clicado
  uses_count        Int      @default(0)    // Quantas vezes foi usado
  new_users_count   Int      @default(0)    // Novos usuários atraídos
  revenue_saved     Int      @default(0)    // Receita economizada (sats)
  
  // Métricas de conversão
  conversion_rate   Float    @default(0)    // Taxa de conversão (uses/views)
  click_through_rate Float   @default(0)    // Taxa de cliques (clicks/views)
  
  created_at        DateTime @default(now()) @db.Timestamp(6)
  
  @@index([coupon_id], map: "idx_coupon_analytics_coupon")
  @@index([date], map: "idx_coupon_analytics_date")
  @@unique([coupon_id, date], map: "idx_coupon_analytics_unique")
}

enum PlanType {
  free
  basic
  advanced
  pro
  lifetime
}

// Sistema de Menu Dinâmico
model MenuItem {
  id          String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  name        String   // Nome exibido no menu
  mobileName  String?  // Nome mais curto para mobile (opcional)
  href        String   // URL/rota
  icon        String   // Nome do ícone (lucide-react)
  order       Int      // Ordem de exibição
  isActive    Boolean  @default(true) // Se está ativo/visível
  isVisible   Boolean  @default(true) // Se deve ser exibido
  target      String   @default("_self") // _self, _blank, etc.
  badge       String?  // Badge/notificação (opcional)
  badgeColor  String?  // Cor do badge (opcional)
  description String?  // Descrição para tooltip
  
  // Relacionamentos
  menuType    MenuType @relation(fields: [menuTypeId], references: [id])
  menuTypeId  String
  
  // Timestamps
  created_at  DateTime @default(now()) @db.Timestamp(6)
  updated_at  DateTime @default(now()) @db.Timestamp(6)
  
  @@index([menuTypeId])
  @@index([order])
  @@index([isActive, isVisible])
}

model MenuType {
  id          String     @id @default(dbgenerated("(gen_random_uuid())::text"))
  name        String     @unique // main, secondary, user
  displayName String     // Nome para exibição
  description String?    // Descrição do tipo de menu
  isActive    Boolean    @default(true)
  
  // Relacionamentos
  menuItems   MenuItem[]
  
  // Timestamps
  created_at  DateTime @default(now()) @db.Timestamp(6)
  updated_at  DateTime @default(now()) @db.Timestamp(6)
}

// Configurações do Sistema
model SystemConfig {
  id          String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  key         String   @unique // chave única da configuração
  value       String   // valor da configuração (JSON string)
  type        String   @default("string") // string, number, boolean, json
  description String?  // descrição da configuração
  isActive    Boolean  @default(true)
  
  // Timestamps
  created_at  DateTime @default(now()) @db.Timestamp(6)
  updated_at  DateTime @default(now()) @db.Timestamp(6)
  
  @@index([key])
  @@index([isActive])
}

model UserUpgradeHistory {
  id            String   @id @default(dbgenerated("gen_random_uuid()"))
  user_id       String
  old_plan      String
  new_plan      String
  reason        String
  effective_date DateTime @db.Timestamp(6)
  upgraded_by   String
  created_at    DateTime @default(now()) @db.Timestamp(6)
  updated_at    DateTime @default(now()) @db.Timestamp(6)

  // Relations
  user    User @relation("UserUpgradeHistory", fields: [user_id], references: [id], onDelete: Cascade)
  admin   User @relation("AdminUpgradeHistory", fields: [upgraded_by], references: [id], onDelete: SetNull)

  @@map("user_upgrade_history")
  @@index([user_id])
  @@index([upgraded_by])
  @@index([created_at])
  @@index([new_plan])
}

// Sistema de Simulação
model Simulation {
  id                String          @id @default(dbgenerated("(gen_random_uuid())::text"))
  user_id           String
  name              String
  automation_type   SimulationType
  price_scenario    PriceScenario
  initial_price     Float
  duration          Int             // em segundos
  status            SimulationStatus @default(created)
  account_id        String?         // ID da conta de teste
  environment       String          @default("testnet")
  created_at        DateTime        @default(now()) @db.Timestamp(6)
  updated_at        DateTime        @default(now()) @db.Timestamp(6)
  started_at        DateTime?       @db.Timestamp(6)
  completed_at      DateTime?       @db.Timestamp(6)

  // Relations
  user              User            @relation(fields: [user_id], references: [id], onDelete: Cascade)
  results           SimulationResult[]

  @@index([user_id])
  @@index([status])
  @@index([automation_type])
  @@index([created_at])
}

model SimulationResult {
  id                String          @id @default(dbgenerated("(gen_random_uuid())::text"))
  simulation_id     String
  timestamp         DateTime        @db.Timestamp(6)
  price             Float
  action_type       String?
  action_details    Json?
  account_balance   Float?
  position_size     Float?
  pnl               Float?
  margin_level      Float?
  success_rate      Float?
  total_actions     Int             @default(0)
  executed_at       DateTime        @db.Timestamp(6)

  // Relations
  simulation        Simulation      @relation(fields: [simulation_id], references: [id], onDelete: Cascade)

  @@index([simulation_id])
  @@index([timestamp])
}

// Enums para Simulação
enum SimulationType {
  margin_guard
  take_profit
  trailing_stop
  auto_entry
}

enum PriceScenario {
  bull
  bear
  sideways
  volatile
}

enum SimulationStatus {
  created
  running
  completed
  failed
  cancelled
}
